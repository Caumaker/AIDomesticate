class MockAsyncLocalStorage {
    getStore() {
        return undefined;
    }
    run(_, callback) {
        return callback();
    }
}
class AsyncLocalStorageProvider {
    constructor() {
        Object.defineProperty(this, "asyncLocalStorage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new MockAsyncLocalStorage()
        });
        Object.defineProperty(this, "hasBeenInitialized", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
    }
    getInstance() {
        return this.asyncLocalStorage;
    }
    initializeGlobalInstance(instance) {
        if (!this.hasBeenInitialized) {
            this.hasBeenInitialized = true;
            this.asyncLocalStorage = instance;
        }
    }
}
export const AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();
/**
 * Return the current run tree from within a traceable-wrapped function.
 * Will throw an error if called outside of a traceable function.
 *
 * @returns The run tree for the given context.
 */
export const getCurrentRunTree = () => {
    const runTree = AsyncLocalStorageProviderSingleton.getInstance().getStore();
    if (runTree === undefined) {
        throw new Error([
            "Could not get the current run tree.",
            "",
            "Please make sure you are calling this method within a traceable function.",
        ].join("\n"));
    }
    return runTree;
};
export const ROOT = Symbol.for("langsmith:traceable:root");
export function isTraceableFunction(x
// eslint-disable-next-line @typescript-eslint/no-explicit-any
) {
    return typeof x === "function" && "langsmith:traceable" in x;
}
